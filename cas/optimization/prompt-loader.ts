/**
 * CAS Optimized Prompt Loader
 *
 * TypeScript loader for DSPy-optimized prompts.
 * Loads optimized prompts from JSON files generated by the Python DSPy pipeline.
 *
 * @module cas/optimization
 *
 * @example
 * ```typescript
 * import { loadOptimizedPrompts, getOptimizedPrompt } from '@cas/optimization';
 *
 * // Load prompts for Sage
 * await loadOptimizedPrompts('sage');
 *
 * // Get optimized prompt for maths
 * const mathsPrompt = getOptimizedPrompt('sage', 'maths');
 * ```
 */

import { readFileSync, existsSync, watchFile, unwatchFile } from 'fs';
import { join } from 'path';

// --- Types ---

export interface OptimizedPromptFile {
  agent_type: 'sage' | 'lexi';
  model: string;
  generated_at: string;
  version: string;
  signatures: Record<string, SignatureOptimization>;
}

export interface SignatureOptimization {
  signature: string;
  status: 'success' | 'skipped' | 'error';
  reason?: string;
  metrics?: {
    before: number;
    after: number;
    improvement: number;
    improvement_pct: number;
  };
  samples_used?: number;
  optimized_prompts?: OptimizedPrompts;
  timestamp: string;
}

export interface OptimizedPrompts {
  demos?: OptimizedDemo[];
  [key: string]: unknown;
}

export interface OptimizedDemo {
  inputs: Record<string, string>;
  outputs: Record<string, string>;
}

export type SignatureType = 'maths' | 'explain' | 'diagnose';
export type AgentType = 'sage' | 'lexi';

// --- State ---

const promptCache: Map<string, OptimizedPromptFile> = new Map();
const watchCallbacks: Map<string, () => void> = new Map();

// --- Core Functions ---

/**
 * Get the path to the optimized prompts file for an agent.
 */
export function getPromptsPath(agentType: AgentType): string {
  return join(__dirname, 'output', `optimized_${agentType}_latest.json`);
}

/**
 * Load optimized prompts for an agent.
 *
 * @param agentType - 'sage' or 'lexi'
 * @param forceReload - Force reload even if cached
 * @returns The loaded prompts or null if file doesn't exist
 */
export function loadOptimizedPrompts(
  agentType: AgentType,
  forceReload = false
): OptimizedPromptFile | null {
  const cacheKey = agentType;

  // Return cached if available and not forcing reload
  if (!forceReload && promptCache.has(cacheKey)) {
    return promptCache.get(cacheKey)!;
  }

  const promptsPath = getPromptsPath(agentType);

  if (!existsSync(promptsPath)) {
    console.warn(`[PromptLoader] No optimized prompts found for ${agentType} at ${promptsPath}`);
    return null;
  }

  try {
    const content = readFileSync(promptsPath, 'utf-8');
    const prompts = JSON.parse(content) as OptimizedPromptFile;

    // Validate structure
    if (!prompts.agent_type || !prompts.signatures) {
      console.error(`[PromptLoader] Invalid prompt file structure for ${agentType}`);
      return null;
    }

    // Cache the loaded prompts
    promptCache.set(cacheKey, prompts);

    console.log(
      `[PromptLoader] Loaded ${Object.keys(prompts.signatures).length} optimized signatures for ${agentType}`,
      `(generated: ${prompts.generated_at})`
    );

    return prompts;
  } catch (error) {
    console.error(`[PromptLoader] Failed to load prompts for ${agentType}:`, error);
    return null;
  }
}

/**
 * Get optimized prompts for a specific signature.
 *
 * @param agentType - 'sage' or 'lexi'
 * @param signature - Signature type
 * @returns The optimization data or null
 */
export function getOptimizedSignature(
  agentType: AgentType,
  signature: SignatureType
): SignatureOptimization | null {
  const prompts = loadOptimizedPrompts(agentType);

  if (!prompts) {
    return null;
  }

  const signatureData = prompts.signatures[signature];

  if (!signatureData) {
    console.warn(`[PromptLoader] No optimization found for ${agentType}/${signature}`);
    return null;
  }

  return signatureData;
}

/**
 * Get few-shot demos for a signature.
 *
 * @param agentType - 'sage' or 'lexi'
 * @param signature - Signature type
 * @returns Array of demos or empty array
 */
export function getOptimizedDemos(
  agentType: AgentType,
  signature: SignatureType
): OptimizedDemo[] {
  const optimization = getOptimizedSignature(agentType, signature);

  if (!optimization || optimization.status !== 'success') {
    return [];
  }

  return optimization.optimized_prompts?.demos || [];
}

/**
 * Format optimized demos as few-shot examples for a prompt.
 *
 * @param agentType - 'sage' or 'lexi'
 * @param signature - Signature type
 * @returns Formatted string with few-shot examples
 */
export function formatFewShotExamples(
  agentType: AgentType,
  signature: SignatureType
): string {
  const demos = getOptimizedDemos(agentType, signature);

  if (demos.length === 0) {
    return '';
  }

  const examples: string[] = [];

  for (let i = 0; i < demos.length; i++) {
    const demo = demos[i];
    const exampleParts: string[] = [`Example ${i + 1}:`];

    // Format inputs
    for (const [key, value] of Object.entries(demo.inputs)) {
      exampleParts.push(`${key}: ${value}`);
    }

    // Format outputs
    for (const [key, value] of Object.entries(demo.outputs)) {
      exampleParts.push(`${key}: ${value}`);
    }

    examples.push(exampleParts.join('\n'));
  }

  return examples.join('\n\n');
}

/**
 * Get optimization metrics for a signature.
 *
 * @param agentType - 'sage' or 'lexi'
 * @param signature - Signature type
 * @returns Metrics or null
 */
export function getOptimizationMetrics(
  agentType: AgentType,
  signature: SignatureType
): SignatureOptimization['metrics'] | null {
  const optimization = getOptimizedSignature(agentType, signature);
  return optimization?.metrics || null;
}

/**
 * Check if optimized prompts are available and recent.
 *
 * @param agentType - 'sage' or 'lexi'
 * @param maxAgeDays - Maximum age in days (default: 14)
 * @returns True if prompts are available and recent
 */
export function hasRecentOptimization(
  agentType: AgentType,
  maxAgeDays = 14
): boolean {
  const prompts = loadOptimizedPrompts(agentType);

  if (!prompts) {
    return false;
  }

  const generatedAt = new Date(prompts.generated_at);
  const maxAge = maxAgeDays * 24 * 60 * 60 * 1000;
  const age = Date.now() - generatedAt.getTime();

  return age < maxAge;
}

/**
 * Watch for changes to optimized prompts file.
 * Automatically reloads when the file changes.
 *
 * @param agentType - 'sage' or 'lexi'
 * @param callback - Optional callback when prompts are reloaded
 */
export function watchOptimizedPrompts(
  agentType: AgentType,
  callback?: (prompts: OptimizedPromptFile | null) => void
): () => void {
  const promptsPath = getPromptsPath(agentType);
  const watchKey = agentType;

  // Clean up existing watcher
  if (watchCallbacks.has(watchKey)) {
    unwatchFile(promptsPath);
  }

  const onChange = () => {
    console.log(`[PromptLoader] Reloading optimized prompts for ${agentType}...`);
    const prompts = loadOptimizedPrompts(agentType, true);
    callback?.(prompts);
  };

  watchCallbacks.set(watchKey, onChange);

  if (existsSync(promptsPath)) {
    watchFile(promptsPath, { interval: 5000 }, onChange);
  }

  // Return cleanup function
  return () => {
    if (existsSync(promptsPath)) {
      unwatchFile(promptsPath);
    }
    watchCallbacks.delete(watchKey);
  };
}

/**
 * Clear the prompt cache.
 */
export function clearPromptCache(): void {
  promptCache.clear();
}

/**
 * Get all available optimizations for an agent.
 *
 * @param agentType - 'sage' or 'lexi'
 * @returns Map of signature to optimization status
 */
export function getOptimizationStatus(
  agentType: AgentType
): Map<SignatureType, { status: string; improvement?: number }> {
  const result = new Map<SignatureType, { status: string; improvement?: number }>();
  const prompts = loadOptimizedPrompts(agentType);

  if (!prompts) {
    return result;
  }

  for (const [sig, data] of Object.entries(prompts.signatures)) {
    result.set(sig as SignatureType, {
      status: data.status,
      improvement: data.metrics?.improvement_pct,
    });
  }

  return result;
}
